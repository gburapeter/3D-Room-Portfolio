type ICallback = (t: number) => void;
/**
 * The number of ticks that can pass without any scheduled callbacks before the Ticker goes dormant. This is to prevent
 * the Ticker from staying active forever, even if there are no scheduled callbacks.
 *
 * Perhaps counting ticks vs. time is not the best way to do this. But it's a start.
 */
export declare const EMPTY_TICKS_BEFORE_GOING_DORMANT: number;
/**
 * The Ticker class helps schedule callbacks. Scheduled callbacks are executed per tick. Ticks can be triggered by an
 * external scheduling strategy, e.g. a raf.
 */
export default class Ticker {
    private _conf?;
    private _scheduledForThisOrNextTick;
    private _scheduledForNextTick;
    private _timeAtCurrentTick;
    private _ticking;
    /**
     * Whether the Ticker is dormant
     */
    private _dormant;
    private _numberOfDormantTicks;
    /**
     * Whether the Ticker is dormant
     */
    get dormant(): boolean;
    /**
     * Counts up for every tick executed.
     * Internally, this is used to measure ticks per second.
     *
     * This is "public" to TypeScript, because it's a tool for performance measurements.
     * Consider this as experimental, and do not rely on it always being here in future releases.
     */
    __ticks: number;
    constructor(_conf?: {
        /**
         * This is called when the Ticker goes dormant.
         */
        onDormant?: (() => void) | undefined;
        /**
         * This is called when the Ticker goes active.
         */
        onActive?: (() => void) | undefined;
    } | undefined);
    /**
     * Registers for fn to be called either on this tick or the next tick.
     *
     * If `onThisOrNextTick()` is called while `Ticker.tick()` is running, the
     * side effect _will_ be called within the running tick. If you don't want this
     * behavior, you can use `onNextTick()`.
     *
     * Note that `fn` will be added to a `Set()`. Which means, if you call `onThisOrNextTick(fn)`
     * with the same fn twice in a single tick, it'll only run once.
     *
     * @param fn - The function to be registered.
     *
     * @see offThisOrNextTick
     */
    onThisOrNextTick(fn: ICallback): void;
    /**
     * Registers a side effect to be called on the next tick.
     *
     * @param fn - The function to be registered.
     *
     * @see onThisOrNextTick
     * @see offNextTick
     */
    onNextTick(fn: ICallback): void;
    /**
     * De-registers a fn to be called either on this tick or the next tick.
     *
     * @param fn - The function to be de-registered.
     *
     * @see onThisOrNextTick
     */
    offThisOrNextTick(fn: ICallback): void;
    /**
     * De-registers a fn to be called on the next tick.
     *
     * @param fn - The function to be de-registered.
     *
     * @see onNextTick
     */
    offNextTick(fn: ICallback): void;
    /**
     * The time at the start of the current tick if there is a tick in progress, otherwise defaults to
     * `performance.now()`.
     */
    get time(): number;
    private _goActive;
    private _goDormant;
    /**
     * Triggers a tick which starts executing the callbacks scheduled for this tick.
     *
     * @param t - The time at the tick.
     *
     * @see onThisOrNextTick
     * @see onNextTick
     */
    tick(t?: number): void;
    private _tick;
}
export {};
//# sourceMappingURL=Ticker.d.ts.map