import type { $IntentionalAny, VoidFn } from '../types';
import type { Prism } from './Interface';
type IRef<T> = {
    current: T;
};
/**
 * Just like React's `useRef()`, `prism.ref()` allows us to create a prism that holds a reference to some value.
 * The only difference is that `prism.ref()` requires a key to be passed into it, whlie `useRef()` doesn't.
 * This means that we can call `prism.ref()` in any order, and we can call it multiple times with the same key.
 * @param key - The key for the ref. Should be unique inside of the prism.
 * @param initialValue - The initial value for the ref.
 * @returns `{current: V}` - The ref object.
 *
 * Note that the ref object will always return its initial value if the prism is cold. It'll only record
 * its current value if the prism is hot (and will forget again if the prism goes cold again).
 *
 * @example
 * ```ts
 * const pr = prism(() => {
 *   const ref1 = prism.ref("ref1", 0)
 *   console.log(ref1.current) // will print 0, and if the prism is hot, it'll print the current value
 *   ref1.current++ // changing the current value of the ref
 * })
 * ```
 */
declare function ref<T>(key: string, initialValue: T): IRef<T>;
/**
 * An effect hook, similar to React's `useEffect()`, but is not sensitive to call order by using `key`.
 *
 * @param key - the key for the effect. Should be uniqe inside of the prism.
 * @param cb - the callback function. Requires returning a cleanup function.
 * @param deps - the dependency array
 */
declare function effect(key: string, cb: () => () => void, deps?: unknown[]): void;
/**
 * `prism.memo()` works just like React's `useMemo()` hook. It's a way to cache the result of a function call.
 * The only difference is that `prism.memo()` requires a key to be passed into it, whlie `useMemo()` doesn't.
 * This means that we can call `prism.memo()` in any order, and we can call it multiple times with the same key.
 *
 * @param key - The key for the memo. Should be unique inside of the prism
 * @param fn - The function to memoize
 * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.
 * @returns The result of the function call
 *
 * @example
 * ```ts
 * const pr = prism(() => {
 *  const memoizedReturnValueOfExpensiveFn = prism.memo("memo1", expensiveFn, [])
 * })
 * ```
 */
declare function memo<T>(key: string, fn: () => T, deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>): T;
/**
 * A state hook, similar to react's `useState()`.
 *
 * @param key - the key for the state
 * @param initialValue - the initial value
 * @returns [currentState, setState]
 *
 * @example
 * ```ts
 * import {prism} from 'dataverse'
 *
 * // This prism holds the current mouse position and updates when the mouse moves
 * const mousePositionD = prism(() => {
 *   const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])
 *
 *   prism.effect(
 *     'setupListeners',
 *     () => {
 *       const handleMouseMove = (e: MouseEvent) => {
 *         setPos([e.screenX, e.screenY])
 *       }
 *       document.addEventListener('mousemove', handleMouseMove)
 *
 *       return () => {
 *         document.removeEventListener('mousemove', handleMouseMove)
 *       }
 *     },
 *     [],
 *   )
 *
 *   return pos
 * })
 * ```
 */
declare function state<T>(key: string, initialValue: T): [T, (val: T) => void];
/**
 * This is useful to make sure your code is running inside a `prism()` call.
 *
 * @example
 * ```ts
 * import {prism} from '@theatre/dataverse'
 *
 * function onlyUsefulInAPrism() {
 *   prism.ensurePrism()
 * }
 *
 * prism(() => {
 *   onlyUsefulInAPrism() // will run fine
 * })
 *
 * setTimeout(() => {
 *   onlyUsefulInAPrism() // throws an error
 *   console.log('This will never get logged')
 * }, 0)
 * ```
 */
declare function ensurePrism(): void;
declare function scope<T>(key: string, fn: () => T): T;
/**
 * Just an alias for `prism.memo(key, () => prism(fn), deps).getValue()`. It creates a new prism, memoizes it, and returns the value.
 * `prism.sub()` is useful when you want to divide your prism into smaller prisms, each of which
 * would _only_ recalculate when _certain_ dependencies change. In other words, it's an optimization tool.
 *
 * @param key - The key for the memo. Should be unique inside of the prism
 * @param fn - The function to run inside the prism
 * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.
 * @returns The value of the inner prism
 */
declare function sub<T>(key: string, fn: () => T, deps: undefined | $IntentionalAny[]): T;
/**
 * @returns true if the current function is running inside a `prism()` call.
 */
declare function inPrism(): boolean;
/**
 * `prism.source()`  allow a prism to react to changes in some external source (other than other prisms).
 * For example, `Atom.pointerToPrism()` uses `prism.source()` to create a prism that reacts to changes in the atom's value.
 
 * @param subscribe - The prism will call this function as soon as the prism goes hot. This function should return an unsubscribe function function which the prism will call when it goes cold.
 * @param getValue - A function that returns the current value of the external source.
 * @returns The current value of the source
 *
 * Example:
 * ```ts
 * function prismFromInputElement(input: HTMLInputElement): Prism<string> {
 *   function listen(cb: (value: string) => void) {
 *     const listener = () => {
 *       cb(input.value)
 *     }
 *     input.addEventListener('input', listener)
 *     return () => {
 *       input.removeEventListener('input', listener)
 *     }
 *   }
 *
 *   function get() {
 *     return input.value
 *   }
 *   return prism(() => prism.source(listen, get))
 * }
 * ```
 */
declare function source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V;
type IPrismFn = {
    <T>(fn: () => T): Prism<T>;
    ref: typeof ref;
    effect: typeof effect;
    memo: typeof memo;
    ensurePrism: typeof ensurePrism;
    state: typeof state;
    scope: typeof scope;
    sub: typeof sub;
    inPrism: typeof inPrism;
    source: typeof source;
};
/**
 * Creates a prism from the passed function that adds all prisms referenced
 * in it as dependencies, and reruns the function when these change.
 *
 * @param fn - The function to rerun when the prisms referenced in it change.
 */
declare const prism: IPrismFn;
export default prism;
//# sourceMappingURL=prism.d.ts.map