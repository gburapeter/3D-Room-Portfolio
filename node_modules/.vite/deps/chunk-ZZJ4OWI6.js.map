{
  "version": 3,
  "sources": ["../../@theatre/dataverse/src/index.ts", "../../node_modules/lodash-es/isArray.js", "../../node_modules/lodash-es/_freeGlobal.js", "../../node_modules/lodash-es/_root.js", "../../node_modules/lodash-es/_Symbol.js", "../../node_modules/lodash-es/_getRawTag.js", "../../node_modules/lodash-es/_objectToString.js", "../../node_modules/lodash-es/_baseGetTag.js", "../../node_modules/lodash-es/isObjectLike.js", "../../node_modules/lodash-es/isSymbol.js", "../../node_modules/lodash-es/_isKey.js", "../../node_modules/lodash-es/isObject.js", "../../node_modules/lodash-es/isFunction.js", "../../node_modules/lodash-es/_coreJsData.js", "../../node_modules/lodash-es/_isMasked.js", "../../node_modules/lodash-es/_toSource.js", "../../node_modules/lodash-es/_baseIsNative.js", "../../node_modules/lodash-es/_getValue.js", "../../node_modules/lodash-es/_getNative.js", "../../node_modules/lodash-es/_nativeCreate.js", "../../node_modules/lodash-es/_hashClear.js", "../../node_modules/lodash-es/_hashDelete.js", "../../node_modules/lodash-es/_hashGet.js", "../../node_modules/lodash-es/_hashHas.js", "../../node_modules/lodash-es/_hashSet.js", "../../node_modules/lodash-es/_Hash.js", "../../node_modules/lodash-es/_listCacheClear.js", "../../node_modules/lodash-es/eq.js", "../../node_modules/lodash-es/_assocIndexOf.js", "../../node_modules/lodash-es/_listCacheDelete.js", "../../node_modules/lodash-es/_listCacheGet.js", "../../node_modules/lodash-es/_listCacheHas.js", "../../node_modules/lodash-es/_listCacheSet.js", "../../node_modules/lodash-es/_ListCache.js", "../../node_modules/lodash-es/_Map.js", "../../node_modules/lodash-es/_mapCacheClear.js", "../../node_modules/lodash-es/_isKeyable.js", "../../node_modules/lodash-es/_getMapData.js", "../../node_modules/lodash-es/_mapCacheDelete.js", "../../node_modules/lodash-es/_mapCacheGet.js", "../../node_modules/lodash-es/_mapCacheHas.js", "../../node_modules/lodash-es/_mapCacheSet.js", "../../node_modules/lodash-es/_MapCache.js", "../../node_modules/lodash-es/memoize.js", "../../node_modules/lodash-es/_memoizeCapped.js", "../../node_modules/lodash-es/_stringToPath.js", "../../node_modules/lodash-es/_arrayMap.js", "../../node_modules/lodash-es/_baseToString.js", "../../node_modules/lodash-es/toString.js", "../../node_modules/lodash-es/_castPath.js", "../../node_modules/lodash-es/_toKey.js", "../../node_modules/lodash-es/_baseGet.js", "../../node_modules/lodash-es/get.js", "../../node_modules/lodash-es/_overArg.js", "../../node_modules/lodash-es/_getPrototype.js", "../../node_modules/lodash-es/isPlainObject.js", "../../node_modules/lodash-es/last.js", "../../@theatre/dataverse/src/pointer.ts", "../../@theatre/dataverse/src/utils/updateDeep.ts", "../../@theatre/dataverse/src/utils/Stack.ts", "../../@theatre/dataverse/src/prism/Interface.ts", "../../@theatre/dataverse/src/prism/discoveryMechanism.ts", "../../@theatre/dataverse/src/prism/prism.ts", "../../@theatre/dataverse/src/Atom.ts", "../../@theatre/dataverse/src/pointerToPrism.ts", "../../@theatre/dataverse/src/val.ts", "../../@theatre/dataverse/src/prism/iterateAndCountTicks.ts", "../../@theatre/dataverse/src/Ticker.ts", "../../@theatre/dataverse/src/prism/iterateOver.ts", "../../@theatre/dataverse/src/PointerProxy.ts"],
  "sourcesContent": ["/**\n * The animation-optimized FRP library powering the internals of Theatre.js.\n *\n * @packageDocumentation\n */\n\nexport type {PointerToPrismProvider} from './pointerToPrism'\nexport {default as Atom} from './Atom'\nexport {val} from './val'\nexport {pointerToPrism} from './pointerToPrism'\nexport {isPrism} from './prism/Interface'\nexport type {Prism} from './prism/Interface'\nexport {default as iterateAndCountTicks} from './prism/iterateAndCountTicks'\nexport {default as iterateOver} from './prism/iterateOver'\nexport {default as prism} from './prism/prism'\nexport {default as pointer, getPointerParts, isPointer} from './pointer'\nexport type {Pointer, PointerType, PointerMeta} from './pointer'\nexport {default as Ticker} from './Ticker'\nexport {default as PointerProxy} from './PointerProxy'\n", "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n", "import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n", "import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n", "import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n", "import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n", "import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n", "import isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n", "import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n", "import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n", "import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n", "/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n", "import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n", "/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n", "import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n", "import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n", "import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n", "/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n", "import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n", "/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n", "/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n", "import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n", "import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n", "import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n", "import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n", "/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n", "import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n", "import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n", "import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n", "import memoize from './memoize.js';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nexport default memoizeCapped;\n", "import memoizeCapped from './_memoizeCapped.js';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n", "/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n", "import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n", "import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n", "import isArray from './isArray.js';\nimport isKey from './_isKey.js';\nimport stringToPath from './_stringToPath.js';\nimport toString from './toString.js';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nexport default castPath;\n", "import isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n", "import castPath from './_castPath.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n", "import baseGet from './_baseGet.js';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n", "/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n", "import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n", "import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n", "/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n", "import type {$IntentionalAny} from './types'\n\ntype PathToProp = Array<string | number>\n\nexport type PointerMeta = {\n  root: {}\n  path: (string | number)[]\n}\n\n/** We are using an empty object as a WeakMap key for storing pointer meta data */\ntype WeakPointerKey = {}\n\nexport type UnindexableTypesForPointer =\n  | number\n  | string\n  | boolean\n  | null\n  | void\n  | undefined\n  | Function // eslint-disable-line @typescript-eslint/ban-types\n\nexport type UnindexablePointer = {\n  [K in $IntentionalAny]: Pointer<undefined>\n}\n\nconst pointerMetaWeakMap = new WeakMap<WeakPointerKey, PointerMeta>()\nconst cachedSubPathPointersWeakMap = new WeakMap<\n  WeakPointerKey,\n  Map<string | number, Pointer<unknown>>\n>()\n\n/**\n * A wrapper type for the type a `Pointer` points to.\n */\nexport type PointerType<O> = {\n  /**\n   * Only accessible via the type system.\n   * This is a helper for getting the underlying pointer type\n   * via the type space.\n   */\n  $$__pointer_type: O\n}\n\n/**\n * The type of {@link Atom} pointers. See {@link pointer|pointer()} for an\n * explanation of pointers.\n *\n * @see Atom\n *\n * @remarks\n * The Pointer type is quite tricky because it doesn't play well with `any` and other inexact types.\n * Here is an example that one would expect to work, but currently doesn't:\n * ```ts\n * declare function expectAnyPointer(pointer: Pointer<any>): void\n *\n * expectAnyPointer(null as Pointer<{}>) // this shows as a type error because Pointer<{}> is not assignable to Pointer<any>, even though it should\n * ```\n *\n * The current solution is to just avoid using `any` with pointer-related code (or type-test it well).\n * But if you enjoy solving typescript puzzles, consider fixing this :)\n * Potentially, [TypeScript variance annotations in 4.7+](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#optional-variance-annotations-for-type-parameters)\n * might be able to help us.\n */\nexport type Pointer<O> = PointerType<O> &\n  // `Exclude<O, undefined>` will remove `undefined` from the first type\n  // `undefined extends O ? undefined : never` will give us `undefined` if `O` is `... | undefined`\n  PointerInner<Exclude<O, undefined>, undefined extends O ? undefined : never>\n\n// By separating the `O` (non-undefined) from the `undefined` or `never`, we\n// can properly use `O extends ...` to determine the kind of potential value\n// without actually discarding optionality information.\ntype PointerInner<O, Optional> = O extends UnindexableTypesForPointer\n  ? UnindexablePointer\n  : unknown extends O\n  ? UnindexablePointer\n  : O extends (infer T)[]\n  ? Pointer<T>[]\n  : O extends {}\n  ? {\n      [K in keyof O]-?: Pointer<O[K] | Optional>\n    }\n  : UnindexablePointer\n\nconst pointerMetaSymbol = Symbol('pointerMeta')\n\nconst proxyHandler = {\n  get(\n    pointerKey: WeakPointerKey,\n    prop: string | typeof pointerMetaSymbol,\n  ): $IntentionalAny {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey)!\n\n    let subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey)\n    if (!subPathPointers) {\n      subPathPointers = new Map()\n      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers)\n    }\n\n    const existing = subPathPointers.get(prop)\n    if (existing !== undefined) return existing\n\n    const meta = pointerMetaWeakMap.get(pointerKey)!\n\n    const subPointer = pointer({root: meta.root, path: [...meta.path, prop]})\n    subPathPointers.set(prop, subPointer)\n    return subPointer\n  },\n}\n\n/**\n * Returns the metadata associated with the pointer. Usually the root object and\n * the path.\n *\n * @param p - The pointer.\n */\nexport const getPointerMeta = <_>(p: PointerType<_>): PointerMeta => {\n  // @ts-ignore @todo\n  const meta: PointerMeta = p[\n    pointerMetaSymbol as unknown as $IntentionalAny\n  ] as $IntentionalAny\n  return meta\n}\n\n/**\n * Returns the root object and the path of the pointer.\n *\n * @example\n * ```ts\n * const {root, path} = getPointerParts(pointer)\n * ```\n *\n * @param p - The pointer.\n *\n * @returns An object with two properties: `root`-the root object or the pointer, and `path`-the path of the pointer. `path` is an array of the property-chain.\n */\nexport const getPointerParts = <_>(\n  p: Pointer<_>,\n): {root: {}; path: PathToProp} => {\n  const {root, path} = getPointerMeta(p)\n  return {root, path}\n}\n\n/**\n * Creates a pointer to a (nested) property of an {@link Atom}.\n *\n * @remarks\n * Pointers are used to make prisms of properties or nested properties of\n * {@link Atom|Atoms}.\n *\n * Pointers also allow easy construction of new pointers pointing to nested members\n * of the root object, by simply using property chaining. E.g. `somePointer.a.b` will\n * create a new pointer that has `'a'` and `'b'` added to the path of `somePointer`.\n *\n * @example\n * ```ts\n * // Here, sum is a prism that updates whenever the a or b prop of someAtom does.\n * const sum = prism(() => {\n *   return val(pointer({root: someAtom, path: ['a']})) + val(pointer({root: someAtom, path: ['b']}));\n * });\n *\n * // Note, atoms have a convenience Atom.pointer property that points to the root,\n * // which you would normally use in this situation.\n * const sum = prism(() => {\n *   return val(someAtom.pointer.a) + val(someAtom.pointer.b);\n * });\n * ```\n *\n * @param args - The pointer parameters.\n *\n * @typeParam O - The type of the value being pointed to.\n */\nfunction pointer<O>(args: {root: {}; path?: Array<string | number>}) {\n  const meta: PointerMeta = {\n    root: args.root as $IntentionalAny,\n    path: args.path ?? [],\n  }\n  const pointerKey: WeakPointerKey = {}\n  pointerMetaWeakMap.set(pointerKey, meta)\n  return new Proxy(pointerKey, proxyHandler) as Pointer<O>\n}\n\nexport default pointer\n\n/**\n * Returns whether `p` is a pointer.\n */\nexport const isPointer = (p: $IntentionalAny): p is Pointer<unknown> => {\n  return p && !!getPointerMeta(p)\n}\n", "import type {$FixMe, $IntentionalAny} from '../types'\n\nexport default function updateDeep<S>(\n  state: S,\n  path: (string | number | undefined)[],\n  reducer: (...args: $IntentionalAny[]) => $IntentionalAny,\n): S {\n  if (path.length === 0) return reducer(state)\n  return hoop(state, path as $IntentionalAny, reducer)\n}\n\nconst hoop = (\n  s: $FixMe,\n  path: (string | number)[],\n  reducer: $FixMe,\n): $FixMe => {\n  if (path.length === 0) {\n    return reducer(s)\n  }\n  if (Array.isArray(s)) {\n    let [index, ...restOfPath] = path\n    index = parseInt(String(index), 10)\n    if (isNaN(index)) index = 0\n    const oldVal = s[index]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = [...s]\n    newS.splice(index, 1, newVal)\n    return newS\n  } else if (typeof s === 'object' && s !== null) {\n    const [key, ...restOfPath] = path\n    const oldVal = s[key]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = {...s, [key]: newVal}\n    return newS\n  } else {\n    const [key, ...restOfPath] = path\n\n    return {[key]: hoop(undefined, restOfPath, reducer)}\n  }\n}\n", "interface Node<Data> {\n  next: undefined | Node<Data>\n  data: Data\n}\n\n/**\n * Just a simple LinkedList\n */\nexport default class Stack<Data> {\n  _head: undefined | Node<Data>\n\n  constructor() {\n    this._head = undefined\n  }\n\n  peek() {\n    return this._head && this._head.data\n  }\n\n  pop() {\n    const head = this._head\n    if (!head) {\n      return undefined\n    }\n    this._head = head.next\n    return head.data\n  }\n\n  push(data: Data) {\n    const node = {next: this._head, data}\n    this._head = node\n  }\n}\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\n\ntype IDependent = (msgComingFrom: Prism<$IntentionalAny>) => void\n\n/**\n * Common interface for prisms.\n */\nexport interface Prism<V> {\n  /**\n   * Whether the object is a prism.\n   */\n  isPrism: true\n\n  /**\n   * Whether the prism is hot.\n   */\n  isHot: boolean\n\n  /**\n   * Calls `listener` with a fresh value every time the prism _has_ a new value, throttled by Ticker.\n   */\n  onChange(\n    ticker: Ticker,\n    listener: (v: V) => void,\n    immediate?: boolean,\n  ): VoidFn\n\n  onStale(cb: () => void): VoidFn\n\n  /**\n   * Keep the prism hot, even if there are no tappers (subscribers).\n   */\n  keepHot(): VoidFn\n\n  /**\n   * Add a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be made a dependent of this prism.\n   *\n   * @see _removeDependent\n   *\n   * @internal\n   */\n  _addDependent(d: IDependent): void\n\n  /**\n   * Remove a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be removed from as a dependent of this prism.\n   *\n   * @see _addDependent\n   * @internal\n   */\n  _removeDependent(d: IDependent): void\n\n  /**\n   * Gets the current value of the prism. If the value is stale, it causes the prism to freshen.\n   */\n  getValue(): V\n}\n\n/**\n * Returns whether `d` is a prism.\n */\nexport function isPrism(d: any): d is Prism<unknown> {\n  return !!(d && d.isPrism && d.isPrism === true)\n}\n", "import type {$IntentionalAny} from '../types'\nimport Stack from '../utils/Stack'\nimport type {Prism} from './Interface'\n\nfunction createMechanism() {\n  const noop = () => {}\n\n  const stack = new Stack<Collector>()\n  const noopCollector: Collector = noop\n\n  type Collector = (d: Prism<$IntentionalAny>) => void\n\n  const pushCollector = (collector: Collector): void => {\n    stack.push(collector)\n  }\n\n  const popCollector = (collector: Collector): void => {\n    const existing = stack.peek()\n    if (existing !== collector) {\n      throw new Error(`Popped collector is not on top of the stack`)\n    }\n    stack.pop()\n  }\n\n  const startIgnoringDependencies = () => {\n    stack.push(noopCollector)\n  }\n\n  const stopIgnoringDependencies = () => {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('This should never happen')\n      }\n    } else {\n      stack.pop()\n    }\n  }\n\n  const reportResolutionStart = (d: Prism<$IntentionalAny>) => {\n    const possibleCollector = stack.peek()\n    if (possibleCollector) {\n      possibleCollector(d)\n    }\n\n    stack.push(noopCollector)\n  }\n\n  const reportResolutionEnd = (_d: Prism<$IntentionalAny>) => {\n    stack.pop()\n  }\n\n  return {\n    type: 'Dataverse_discoveryMechanism' as 'Dataverse_discoveryMechanism',\n    startIgnoringDependencies,\n    stopIgnoringDependencies,\n    reportResolutionStart,\n    reportResolutionEnd,\n    pushCollector,\n    popCollector,\n  }\n}\n\nfunction getSharedMechanism(): ReturnType<typeof createMechanism> {\n  const varName = '__dataverse_discoveryMechanism_sharedStack'\n  const root =\n    typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {}\n  if (root) {\n    const existingMechanism: ReturnType<typeof createMechanism> | undefined =\n      // @ts-ignore ignore\n      root[varName]\n    if (\n      existingMechanism &&\n      typeof existingMechanism === 'object' &&\n      existingMechanism.type === 'Dataverse_discoveryMechanism'\n    ) {\n      return existingMechanism\n    } else {\n      const mechanism = createMechanism()\n      // @ts-ignore ignore\n      root[varName] = mechanism\n      return mechanism\n    }\n  } else {\n    return createMechanism()\n  }\n}\n\nexport const {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  reportResolutionEnd,\n  reportResolutionStart,\n  pushCollector,\n  popCollector,\n} = getSharedMechanism()\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport Stack from '../utils/Stack'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\nimport {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  pushCollector,\n  popCollector,\n  reportResolutionStart,\n  reportResolutionEnd,\n} from './discoveryMechanism'\n\ntype IDependent = (msgComingFrom: Prism<$IntentionalAny>) => void\n\nconst voidFn = () => {}\n\nclass HotHandle<V> {\n  private _didMarkDependentsAsStale: boolean = false\n  private _isFresh: boolean = false\n  protected _cacheOfDendencyValues: Map<Prism<unknown>, unknown> = new Map()\n\n  /**\n   * @internal\n   */\n  protected _dependents: Set<IDependent> = new Set()\n\n  /**\n   * @internal\n   */\n  protected _dependencies: Set<Prism<$IntentionalAny>> = new Set()\n\n  protected _possiblyStaleDeps = new Set<Prism<unknown>>()\n\n  private _scope: HotScope = new HotScope(\n    this as $IntentionalAny as HotHandle<unknown>,\n  )\n\n  /**\n   * @internal\n   */\n  protected _lastValue: undefined | V = undefined\n\n  /**\n   * If true, the prism is stale even though its dependencies aren't\n   * marked as such. This is used by `prism.source()` and `prism.state()`\n   * to mark the prism as stale.\n   */\n  private _forciblySetToStale: boolean = false\n\n  constructor(\n    private readonly _fn: () => V,\n    private readonly _prismInstance: PrismInstance<V>,\n  ) {\n    for (const d of this._dependencies) {\n      d._addDependent(this._reactToDependencyGoingStale)\n    }\n\n    startIgnoringDependencies()\n    this.getValue()\n    stopIgnoringDependencies()\n  }\n\n  get hasDependents(): boolean {\n    return this._dependents.size > 0\n  }\n  removeDependent(d: IDependent) {\n    this._dependents.delete(d)\n  }\n  addDependent(d: IDependent) {\n    this._dependents.add(d)\n  }\n\n  destroy() {\n    for (const d of this._dependencies) {\n      d._removeDependent(this._reactToDependencyGoingStale)\n    }\n    cleanupScopeStack(this._scope)\n  }\n\n  getValue(): V {\n    if (!this._isFresh) {\n      const newValue = this._recalculate()\n      this._lastValue = newValue\n      this._isFresh = true\n      this._didMarkDependentsAsStale = false\n      this._forciblySetToStale = false\n    }\n    return this._lastValue!\n  }\n\n  _recalculate() {\n    let value: V\n\n    if (!this._forciblySetToStale) {\n      if (this._possiblyStaleDeps.size > 0) {\n        let anActuallyStaleDepWasFound = false\n        startIgnoringDependencies()\n        for (const dep of this._possiblyStaleDeps) {\n          if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n            anActuallyStaleDepWasFound = true\n            break\n          }\n        }\n        stopIgnoringDependencies()\n        this._possiblyStaleDeps.clear()\n        if (!anActuallyStaleDepWasFound) {\n          return this._lastValue!\n        }\n      }\n    }\n\n    const newDeps: Set<Prism<unknown>> = new Set()\n    this._cacheOfDendencyValues.clear()\n\n    const collector = (observedDep: Prism<unknown>): void => {\n      newDeps.add(observedDep)\n      this._addDependency(observedDep)\n    }\n\n    pushCollector(collector)\n\n    hookScopeStack.push(this._scope)\n    try {\n      value = this._fn()\n    } catch (error) {\n      console.error(error)\n    } finally {\n      const topOfTheStack = hookScopeStack.pop()\n      if (topOfTheStack !== this._scope) {\n        console.warn(\n          // @todo guide the user to report the bug in an issue\n          `The Prism hook stack has slipped. This is a bug.`,\n        )\n      }\n    }\n\n    popCollector(collector)\n\n    for (const dep of this._dependencies) {\n      if (!newDeps.has(dep)) {\n        this._removeDependency(dep)\n      }\n    }\n\n    this._dependencies = newDeps\n\n    startIgnoringDependencies()\n    for (const dep of newDeps) {\n      this._cacheOfDendencyValues.set(dep, dep.getValue())\n    }\n    stopIgnoringDependencies()\n\n    return value!\n  }\n\n  forceStale() {\n    this._forciblySetToStale = true\n    this._markAsStale()\n  }\n\n  protected _reactToDependencyGoingStale = (which: Prism<$IntentionalAny>) => {\n    this._possiblyStaleDeps.add(which)\n\n    this._markAsStale()\n  }\n\n  private _markAsStale() {\n    if (this._didMarkDependentsAsStale) return\n\n    this._didMarkDependentsAsStale = true\n    this._isFresh = false\n\n    for (const dependent of this._dependents) {\n      dependent(this._prismInstance)\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _addDependency(d: Prism<$IntentionalAny>) {\n    if (this._dependencies.has(d)) return\n    this._dependencies.add(d)\n    d._addDependent(this._reactToDependencyGoingStale)\n  }\n\n  /**\n   * @internal\n   */\n  protected _removeDependency(d: Prism<$IntentionalAny>) {\n    if (!this._dependencies.has(d)) return\n    this._dependencies.delete(d)\n    d._removeDependent(this._reactToDependencyGoingStale)\n  }\n}\n\nconst emptyObject = {}\n\nclass PrismInstance<V> implements Prism<V> {\n  /**\n   * Whether the object is a prism.\n   */\n  readonly isPrism: true = true\n\n  private _state:\n    | {hot: false; handle: undefined}\n    | {hot: true; handle: HotHandle<V>} = {\n    hot: false,\n    handle: undefined,\n  }\n\n  constructor(private readonly _fn: () => V) {}\n\n  /**\n   * Whether the prism is hot.\n   */\n  get isHot(): boolean {\n    return this._state.hot\n  }\n\n  onChange(\n    ticker: Ticker,\n    listener: (v: V) => void,\n    immediate: boolean = false,\n  ): VoidFn {\n    // the prism will call this function every time it goes from fresh to stale\n    const dependent = () => {\n      // schedule the listener to be called on the next tick, unless\n      // we're already on a tick, in which case it'll be called on the current tick.\n      ticker.onThisOrNextTick(refresh)\n    }\n\n    // let's cache the last value so we don't call the listener if the value hasn't changed\n    let lastValue: V | typeof emptyObject =\n      // use an empty object as the initial value so that the listener is called on the first tick.\n      // if we were to use, say, undefined, and this.getValue() also returned undefined, the listener\n      // would never be called.\n      emptyObject\n\n    // this function will be _scheduled_ to be called on the currently running, or next tick,\n    // after the prism has gone from fresh to stale.\n    const refresh = () => {\n      const newValue = this.getValue()\n      // if the value hasn't changed, don't call the listener\n      if (newValue === lastValue) return\n\n      // the value has changed - cache it\n      lastValue = newValue\n\n      // and let the listener know\n      listener(newValue)\n    }\n\n    // add the dependent to the prism's list of dependents (which will make it go hot)\n    this._addDependent(dependent)\n\n    // if the caller wants the listener to be called immediately, call it now\n    if (immediate) {\n      lastValue = this.getValue()\n      listener(lastValue as $IntentionalAny as V)\n    }\n\n    // the unsubscribe function\n    const unsubscribe = () => {\n      // remove the dependent from the prism's list of dependents (and if it was the last dependent, the prism will go cold)\n      this._removeDependent(dependent)\n      // in case we're scheduled for a tick, cancel that\n      ticker.offThisOrNextTick(refresh)\n      ticker.offNextTick(refresh)\n    }\n\n    return unsubscribe\n  }\n\n  /**\n   * Calls `callback` every time the prism's state goes from `fresh-\\>stale.` Returns an `unsubscribe()` function.\n   */\n  onStale(callback: () => void): VoidFn {\n    const untap = () => {\n      this._removeDependent(fn)\n    }\n    const fn = () => callback()\n    this._addDependent(fn)\n    return untap\n  }\n\n  /**\n   * Keep the prism hot, even if there are no tappers (subscribers).\n   */\n  keepHot() {\n    return this.onStale(() => {})\n  }\n\n  /**\n   * Add a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be made a dependent of this prism.\n   *\n   * @see _removeDependent\n   */\n  _addDependent(d: IDependent) {\n    if (!this._state.hot) {\n      this._goHot()\n    }\n    this._state.handle!.addDependent(d)\n  }\n\n  private _goHot() {\n    const hotHandle = new HotHandle(this._fn, this)\n    this._state = {\n      hot: true,\n      handle: hotHandle,\n    }\n  }\n\n  /**\n   * Remove a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be removed from as a dependent of this prism.\n   *\n   * @see _addDependent\n   */\n  _removeDependent(d: IDependent) {\n    const state = this._state\n    if (!state.hot) {\n      return\n    }\n    const handle = state.handle\n    handle.removeDependent(d)\n    if (!handle.hasDependents) {\n      this._state = {hot: false, handle: undefined}\n      handle.destroy()\n    }\n  }\n\n  /**\n   * Gets the current value of the prism. If the value is stale, it causes the prism to freshen.\n   */\n  getValue(): V {\n    /**\n     * TODO We should prevent (or warn about) a common mistake users make, which is reading the value of\n     * a prism in the body of a react component (e.g. `der.getValue()` (often via `val()`) instead of `useVal()`\n     * or `uesPrism()`).\n     *\n     * Although that's the most common example of this mistake, you can also find it outside of react components.\n     * Basically the user runs `der.getValue()` assuming the read is detected by a wrapping prism when it's not.\n     *\n     * Sometiems the prism isn't even hot when the user assumes it is.\n     *\n     * We can fix this type of mistake by:\n     * 1. Warning the user when they call `getValue()` on a cold prism.\n     * 2. Warning the user about calling `getValue()` on a hot-but-stale prism\n     *    if `getValue()` isn't called by a known mechanism like a `PrismEmitter`.\n     *\n     * Design constraints:\n     * - This fix should not have a perf-penalty in production. Perhaps use a global flag + `process.env.NODE_ENV !== 'production'`\n     *   to enable it.\n     * - In the case of `onStale()`, we don't control when the user calls\n     *   `getValue()` (as opposed to `onChange()` which calls `getValue()` directly).\n     *   Perhaps we can disable the check in that case.\n     * - Probably the best place to add this check is right here in this method plus some changes to `reportResulutionStart()`,\n     *   which would have to be changed to let the caller know if there is an actual collector (a prism)\n     *   present in its stack.\n     */\n    reportResolutionStart(this)\n\n    const state = this._state\n\n    let val: V\n    if (state.hot) {\n      val = state.handle.getValue()\n    } else {\n      val = calculateColdPrism(this._fn)\n    }\n\n    reportResolutionEnd(this)\n    return val\n  }\n}\n\ninterface PrismScope {\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n  ): T\n  state<T>(key: string, initialValue: T): [T, (val: T) => void]\n  ref<T>(key: string, initialValue: T): IRef<T>\n  sub(key: string): PrismScope\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V\n}\n\nclass HotScope implements PrismScope {\n  constructor(private readonly _hotHandle: HotHandle<unknown>) {}\n\n  protected readonly _refs: Map<string, IRef<unknown>> = new Map()\n  ref<T>(key: string, initialValue: T): IRef<T> {\n    let ref = this._refs.get(key)\n    if (ref !== undefined) {\n      return ref as $IntentionalAny as IRef<T>\n    } else {\n      const ref = {\n        current: initialValue,\n      }\n      this._refs.set(key, ref)\n      return ref\n    }\n  }\n  isPrismScope = true\n\n  // NOTE probably not a great idea to eager-allocate all of these objects/maps for every scope,\n  // especially because most wouldn't get used in the majority of cases. However, back when these\n  // were stored on weakmaps, they were uncomfortable to inspect in the debugger.\n  readonly subs: Record<string, HotScope> = {}\n  readonly effects: Map<string, IEffect> = new Map()\n\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n    let effect = this.effects.get(key)\n    if (effect === undefined) {\n      effect = {\n        cleanup: voidFn,\n        deps: undefined,\n      }\n      this.effects.set(key, effect)\n    }\n\n    if (depsHaveChanged(effect.deps, deps)) {\n      effect.cleanup()\n\n      startIgnoringDependencies()\n      effect.cleanup = safelyRun(cb, voidFn).value\n      stopIgnoringDependencies()\n      effect.deps = deps\n    }\n    /**\n     * TODO: we should cleanup dangling effects too.\n     * Example:\n     * ```ts\n     * let i = 0\n     * prism(() => {\n     *   if (i === 0) prism.effect(\"this effect will only run once\", () => {}, [])\n     *   i++\n     * })\n     * ```\n     */\n  }\n\n  readonly memos: Map<string, IMemo> = new Map()\n\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n  ): T {\n    let memo = this.memos.get(key)\n    if (memo === undefined) {\n      memo = {\n        cachedValue: null,\n        // undefined will always indicate \"deps have changed\", so we set its initial value as such\n        deps: undefined,\n      }\n      this.memos.set(key, memo)\n    }\n\n    if (depsHaveChanged(memo.deps, deps)) {\n      startIgnoringDependencies()\n\n      memo.cachedValue = safelyRun(fn, undefined).value\n      stopIgnoringDependencies()\n      memo.deps = deps\n    }\n\n    return memo.cachedValue as $IntentionalAny as T\n  }\n\n  state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n    const {value, setValue} = this.memo(\n      'state/' + key,\n      () => {\n        const value = {current: initialValue}\n        const setValue = (newValue: T) => {\n          value.current = newValue\n          this._hotHandle.forceStale()\n        }\n        return {value, setValue}\n      },\n      [],\n    )\n\n    return [value.current, setValue]\n  }\n\n  sub(key: string): HotScope {\n    if (!this.subs[key]) {\n      this.subs[key] = new HotScope(this._hotHandle)\n    }\n    return this.subs[key]\n  }\n\n  cleanupEffects() {\n    for (const effect of this.effects.values()) {\n      safelyRun(effect.cleanup, undefined)\n    }\n    this.effects.clear()\n  }\n\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V {\n    const sourceKey = '$$source/blah'\n    this.effect(\n      sourceKey,\n      () => {\n        const unsub = subscribe(() => {\n          this._hotHandle.forceStale()\n        })\n        return unsub\n      },\n      [subscribe],\n    )\n    return getValue()\n  }\n}\n\nfunction cleanupScopeStack(scope: HotScope) {\n  for (const sub of Object.values(scope.subs)) {\n    cleanupScopeStack(sub)\n  }\n  scope.cleanupEffects()\n}\n\nfunction safelyRun<T, U>(\n  fn: () => T,\n  returnValueInCaseOfError: U,\n): {ok: true; value: T} | {ok: false; value: U} {\n  try {\n    return {value: fn(), ok: true}\n  } catch (error) {\n    // Naming this function can allow the error reporter additional context to the user on where this error came from\n    setTimeout(function PrismReportThrow() {\n      // ensure that the error gets reported, but does not crash the current execution scope\n      throw error\n    })\n    return {value: returnValueInCaseOfError, ok: false}\n  }\n}\n\nconst hookScopeStack = new Stack<PrismScope>()\n\ntype IRef<T> = {\n  current: T\n}\n\ntype IEffect = {\n  deps: undefined | unknown[]\n  cleanup: VoidFn\n}\n\ntype IMemo = {\n  deps: undefined | unknown[] | ReadonlyArray<unknown>\n  cachedValue: unknown\n}\n\n/**\n * Just like React's `useRef()`, `prism.ref()` allows us to create a prism that holds a reference to some value.\n * The only difference is that `prism.ref()` requires a key to be passed into it, whlie `useRef()` doesn't.\n * This means that we can call `prism.ref()` in any order, and we can call it multiple times with the same key.\n * @param key - The key for the ref. Should be unique inside of the prism.\n * @param initialValue - The initial value for the ref.\n * @returns `{current: V}` - The ref object.\n *\n * Note that the ref object will always return its initial value if the prism is cold. It'll only record\n * its current value if the prism is hot (and will forget again if the prism goes cold again).\n *\n * @example\n * ```ts\n * const pr = prism(() => {\n *   const ref1 = prism.ref(\"ref1\", 0)\n *   console.log(ref1.current) // will print 0, and if the prism is hot, it'll print the current value\n *   ref1.current++ // changing the current value of the ref\n * })\n * ```\n */\nfunction ref<T>(key: string, initialValue: T): IRef<T> {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.ref() is called outside of a prism() call.`)\n  }\n\n  return scope.ref(key, initialValue)\n}\n\n/**\n * An effect hook, similar to React's `useEffect()`, but is not sensitive to call order by using `key`.\n *\n * @param key - the key for the effect. Should be uniqe inside of the prism.\n * @param cb - the callback function. Requires returning a cleanup function.\n * @param deps - the dependency array\n */\nfunction effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.effect() is called outside of a prism() call.`)\n  }\n\n  return scope.effect(key, cb, deps)\n}\n\nfunction depsHaveChanged(\n  oldDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n  newDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n): boolean {\n  if (oldDeps === undefined || newDeps === undefined) {\n    return true\n  }\n\n  const len = oldDeps.length\n  if (len !== newDeps.length) return true\n\n  for (let i = 0; i < len; i++) {\n    if (oldDeps[i] !== newDeps[i]) return true\n  }\n\n  return false\n}\n\n/**\n * `prism.memo()` works just like React's `useMemo()` hook. It's a way to cache the result of a function call.\n * The only difference is that `prism.memo()` requires a key to be passed into it, whlie `useMemo()` doesn't.\n * This means that we can call `prism.memo()` in any order, and we can call it multiple times with the same key.\n *\n * @param key - The key for the memo. Should be unique inside of the prism\n * @param fn - The function to memoize\n * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.\n * @returns The result of the function call\n *\n * @example\n * ```ts\n * const pr = prism(() => {\n *  const memoizedReturnValueOfExpensiveFn = prism.memo(\"memo1\", expensiveFn, [])\n * })\n * ```\n */\nfunction memo<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n): T {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.memo() is called outside of a prism() call.`)\n  }\n\n  return scope.memo(key, fn, deps)\n}\n\n/**\n * A state hook, similar to react's `useState()`.\n *\n * @param key - the key for the state\n * @param initialValue - the initial value\n * @returns [currentState, setState]\n *\n * @example\n * ```ts\n * import {prism} from 'dataverse'\n *\n * // This prism holds the current mouse position and updates when the mouse moves\n * const mousePositionD = prism(() => {\n *   const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])\n *\n *   prism.effect(\n *     'setupListeners',\n *     () => {\n *       const handleMouseMove = (e: MouseEvent) => {\n *         setPos([e.screenX, e.screenY])\n *       }\n *       document.addEventListener('mousemove', handleMouseMove)\n *\n *       return () => {\n *         document.removeEventListener('mousemove', handleMouseMove)\n *       }\n *     },\n *     [],\n *   )\n *\n *   return pos\n * })\n * ```\n */\nfunction state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.state() is called outside of a prism() call.`)\n  }\n\n  return scope.state(key, initialValue)\n}\n\n/**\n * This is useful to make sure your code is running inside a `prism()` call.\n *\n * @example\n * ```ts\n * import {prism} from '@theatre/dataverse'\n *\n * function onlyUsefulInAPrism() {\n *   prism.ensurePrism()\n * }\n *\n * prism(() => {\n *   onlyUsefulInAPrism() // will run fine\n * })\n *\n * setTimeout(() => {\n *   onlyUsefulInAPrism() // throws an error\n *   console.log('This will never get logged')\n * }, 0)\n * ```\n */\nfunction ensurePrism(): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`The parent function is called outside of a prism() call.`)\n  }\n}\n\nfunction scope<T>(key: string, fn: () => T): T {\n  const parentScope = hookScopeStack.peek()\n  if (!parentScope) {\n    throw new Error(`prism.scope() is called outside of a prism() call.`)\n  }\n  const subScope = parentScope.sub(key)\n  hookScopeStack.push(subScope)\n  const ret = safelyRun(fn, undefined).value\n  hookScopeStack.pop()\n  return ret as $IntentionalAny as T\n}\n\n/**\n * Just an alias for `prism.memo(key, () => prism(fn), deps).getValue()`. It creates a new prism, memoizes it, and returns the value.\n * `prism.sub()` is useful when you want to divide your prism into smaller prisms, each of which\n * would _only_ recalculate when _certain_ dependencies change. In other words, it's an optimization tool.\n *\n * @param key - The key for the memo. Should be unique inside of the prism\n * @param fn - The function to run inside the prism\n * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.\n * @returns The value of the inner prism\n */\nfunction sub<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[],\n): T {\n  return memo(key, () => prism(fn), deps).getValue()\n}\n\n/**\n * @returns true if the current function is running inside a `prism()` call.\n */\nfunction inPrism(): boolean {\n  return !!hookScopeStack.peek()\n}\n\nconst possiblePrismToValue = <P extends Prism<$IntentionalAny> | unknown>(\n  input: P,\n): P extends Prism<infer T> ? T : P => {\n  if (isPrism(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n\n/**\n * `prism.source()`  allow a prism to react to changes in some external source (other than other prisms).\n * For example, `Atom.pointerToPrism()` uses `prism.source()` to create a prism that reacts to changes in the atom's value.\n \n * @param subscribe - The prism will call this function as soon as the prism goes hot. This function should return an unsubscribe function function which the prism will call when it goes cold.\n * @param getValue - A function that returns the current value of the external source.\n * @returns The current value of the source\n * \n * Example:\n * ```ts\n * function prismFromInputElement(input: HTMLInputElement): Prism<string> {\n *   function listen(cb: (value: string) => void) {\n *     const listener = () => {\n *       cb(input.value)\n *     }\n *     input.addEventListener('input', listener)\n *     return () => {\n *       input.removeEventListener('input', listener)\n *     }\n *   }\n *   \n *   function get() {\n *     return input.value\n *   }\n *   return prism(() => prism.source(listen, get))\n * }\n * ```\n */\nfunction source<V>(\n  subscribe: (fn: (val: V) => void) => VoidFn,\n  getValue: () => V,\n): V {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.source() is called outside of a prism() call.`)\n  }\n\n  return scope.source(subscribe, getValue)\n}\n\ntype IPrismFn = {\n  <T>(fn: () => T): Prism<T>\n  ref: typeof ref\n  effect: typeof effect\n  memo: typeof memo\n  ensurePrism: typeof ensurePrism\n  state: typeof state\n  scope: typeof scope\n  sub: typeof sub\n  inPrism: typeof inPrism\n  source: typeof source\n}\n\n/**\n * Creates a prism from the passed function that adds all prisms referenced\n * in it as dependencies, and reruns the function when these change.\n *\n * @param fn - The function to rerun when the prisms referenced in it change.\n */\nconst prism: IPrismFn = (fn) => {\n  return new PrismInstance(fn)\n}\n\nclass ColdScope implements PrismScope {\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n    console.warn(`prism.effect() does not run in cold prisms`)\n  }\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: any[] | readonly any[] | undefined,\n  ): T {\n    return fn()\n  }\n  state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n    return [initialValue, () => {}]\n  }\n  ref<T>(key: string, initialValue: T): IRef<T> {\n    return {current: initialValue}\n  }\n  sub(key: string): ColdScope {\n    return new ColdScope()\n  }\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V {\n    return getValue()\n  }\n}\n\nfunction calculateColdPrism<V>(fn: () => V): V {\n  const scope = new ColdScope()\n  hookScopeStack.push(scope)\n  let value: V\n  try {\n    value = fn()\n  } catch (error) {\n    console.error(error)\n  } finally {\n    const topOfTheStack = hookScopeStack.pop()\n    if (topOfTheStack !== scope) {\n      console.warn(\n        // @todo guide the user to report the bug in an issue\n        `The Prism hook stack has slipped. This is a bug.`,\n      )\n    }\n  }\n  return value!\n}\n\nprism.ref = ref\nprism.effect = effect\nprism.memo = memo\nprism.ensurePrism = ensurePrism\nprism.state = state\nprism.scope = scope\nprism.sub = sub\nprism.inPrism = inPrism\nprism.source = source\n\nexport default prism\n", "import get from 'lodash-es/get'\nimport isPlainObject from 'lodash-es/isPlainObject'\nimport last from 'lodash-es/last'\nimport type {Prism} from './prism/Interface'\nimport type {Pointer} from './pointer'\nimport {getPointerParts} from './pointer'\nimport {isPointer} from './pointer'\nimport pointer from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport updateDeep from './utils/updateDeep'\nimport prism from './prism/prism'\nimport type {PointerToPrismProvider} from './pointerToPrism'\n\ntype Listener = (newVal: unknown) => void\n\nenum ValueTypes {\n  Dict,\n  Array,\n  Other,\n}\n\nconst getTypeOfValue = (v: unknown): ValueTypes => {\n  if (Array.isArray(v)) return ValueTypes.Array\n  if (isPlainObject(v)) return ValueTypes.Dict\n  return ValueTypes.Other\n}\n\nconst getKeyOfValue = (\n  v: unknown,\n  key: string | number,\n  vType: ValueTypes = getTypeOfValue(v),\n): unknown => {\n  if (vType === ValueTypes.Dict && typeof key === 'string') {\n    return (v as $IntentionalAny)[key]\n  } else if (vType === ValueTypes.Array && isValidArrayIndex(key)) {\n    return (v as $IntentionalAny)[key]\n  } else {\n    return undefined\n  }\n}\n\nconst isValidArrayIndex = (key: string | number): boolean => {\n  const inNumber = typeof key === 'number' ? key : parseInt(key, 10)\n  return (\n    !isNaN(inNumber) &&\n    inNumber >= 0 &&\n    inNumber < Infinity &&\n    (inNumber | 0) === inNumber\n  )\n}\n\nclass Scope {\n  children: Map<string | number, Scope> = new Map()\n  identityChangeListeners: Set<Listener> = new Set()\n  constructor(\n    readonly _parent: undefined | Scope,\n    readonly _path: (string | number)[],\n  ) {}\n\n  addIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.add(cb)\n  }\n\n  removeIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.delete(cb)\n    this._checkForGC()\n  }\n\n  removeChild(key: string | number) {\n    this.children.delete(key)\n    this._checkForGC()\n  }\n\n  getChild(key: string | number) {\n    return this.children.get(key)\n  }\n\n  getOrCreateChild(key: string | number) {\n    let child = this.children.get(key)\n    if (!child) {\n      child = child = new Scope(this, this._path.concat([key]))\n      this.children.set(key, child)\n    }\n    return child\n  }\n\n  _checkForGC() {\n    if (this.identityChangeListeners.size > 0) return\n    if (this.children.size > 0) return\n\n    if (this._parent) {\n      this._parent.removeChild(last(this._path) as string | number)\n    }\n  }\n}\n\n/**\n * Wraps an object whose (sub)properties can be individually tracked.\n */\nexport default class Atom<State> implements PointerToPrismProvider {\n  private _currentState: State\n  /**\n   * @internal\n   */\n  readonly $$isPointerToPrismProvider = true\n  private readonly _rootScope: Scope\n  /**\n   * Convenience property that gives you a pointer to the root of the atom.\n   *\n   * @remarks\n   * Equivalent to `pointer({ root: thisAtom, path: [] })`.\n   */\n  readonly pointer: Pointer<State> = pointer({root: this as $FixMe, path: []})\n\n  readonly prism: Prism<State> = this.pointerToPrism(\n    this.pointer,\n  ) as $IntentionalAny\n\n  constructor(initialState: State) {\n    this._currentState = initialState\n    this._rootScope = new Scope(undefined, [])\n  }\n\n  /**\n   * Sets the state of the atom.\n   *\n   * @param newState - The new state of the atom.\n   */\n  set(newState: State) {\n    const oldState = this._currentState\n    this._currentState = newState\n\n    this._checkUpdates(this._rootScope, oldState, newState)\n  }\n\n  get(): State {\n    return this._currentState\n  }\n\n  /**\n   * Returns the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.getByPointer(atom.pointer.a.b) // 1\n   * atom.getByPointer((p) => p.a.b) // 1\n   * ```\n   */\n  getByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n  ): S {\n    const pointer = isPointer(pointerOrFn)\n      ? pointerOrFn\n      : (pointerOrFn as $IntentionalAny)(this.pointer)\n\n    const path = getPointerParts(pointer).path\n    return this._getIn(path) as S\n  }\n\n  /**\n   * Gets the state of the atom at `path`.\n   */\n  private _getIn(path: (string | number)[]): unknown {\n    return path.length === 0 ? this.get() : get(this.get(), path)\n  }\n\n  reduce(fn: (state: State) => State) {\n    this.set(fn(this.get()))\n  }\n\n  /**\n   * Reduces the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.reduceByPointer(atom.pointer.a.b, (b) => b + 1) // atom.get().a.b === 2\n   * atom.reduceByPointer((p) => p.a.b, (b) => b + 1) // atom.get().a.b === 2\n   * ```\n   */\n  reduceByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n    reducer: (s: S) => S,\n  ) {\n    const pointer = isPointer(pointerOrFn)\n      ? pointerOrFn\n      : (pointerOrFn as $IntentionalAny)(this.pointer)\n\n    const path = getPointerParts(pointer).path\n    const newState = updateDeep(this.get(), path, reducer)\n    this.set(newState)\n  }\n\n  /**\n   * Sets the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.setByPointer(atom.pointer.a.b, 2) // atom.get().a.b === 2\n   * atom.setByPointer((p) => p.a.b, 2) // atom.get().a.b === 2\n   * ```\n   */\n  setByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n    val: S,\n  ) {\n    this.reduceByPointer(pointerOrFn, () => val)\n  }\n\n  private _checkUpdates(scope: Scope, oldState: unknown, newState: unknown) {\n    if (oldState === newState) return\n    for (const cb of scope.identityChangeListeners) {\n      cb(newState)\n    }\n\n    if (scope.children.size === 0) return\n\n    // @todo we can probably skip checking value types\n    const oldValueType = getTypeOfValue(oldState)\n    const newValueType = getTypeOfValue(newState)\n\n    if (oldValueType === ValueTypes.Other && oldValueType === newValueType)\n      return\n\n    for (const [childKey, childScope] of scope.children) {\n      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType)\n      const newChildVal = getKeyOfValue(newState, childKey, newValueType)\n      this._checkUpdates(childScope, oldChildVal, newChildVal)\n    }\n  }\n\n  private _getOrCreateScopeForPath(path: (string | number)[]): Scope {\n    let curScope = this._rootScope\n    for (const pathEl of path) {\n      curScope = curScope.getOrCreateChild(pathEl)\n    }\n    return curScope\n  }\n\n  private _onPointerValueChange = <P>(\n    pointer: Pointer<P>,\n    cb: (v: P) => void,\n  ): (() => void) => {\n    const {path} = getPointerParts(pointer)\n    const scope = this._getOrCreateScopeForPath(path)\n    scope.identityChangeListeners.add(cb as $IntentionalAny)\n    const unsubscribe = () => {\n      scope.identityChangeListeners.delete(cb as $IntentionalAny)\n    }\n    return unsubscribe\n  }\n\n  /**\n   * Returns a new prism of the value at the provided path.\n   *\n   * @param pointer - The path to create the prism at.\n   *\n   * ```ts\n   * const pr = atom({ a: { b: 1 } }).pointerToPrism(atom.pointer.a.b)\n   * pr.getValue() // 1\n   * ```\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P> {\n    const {path} = getPointerParts(pointer)\n    const subscribe = (listener: (val: unknown) => void) =>\n      this._onPointerValueChange(pointer, listener)\n\n    const getValue = () => this._getIn(path)\n\n    return prism(() => {\n      return prism.source(subscribe, getValue)\n    }) as Prism<P>\n  }\n}\n", "import type {Prism} from './prism/Interface'\nimport type {Pointer, PointerType} from './pointer'\nimport {getPointerMeta} from './pointer'\nimport type {$IntentionalAny} from './types'\n\nconst identifyPrismWeakMap = new WeakMap<{}, Prism<unknown>>()\n\n/**\n * Interface for objects that can provide a prism at a certain path.\n */\nexport interface PointerToPrismProvider {\n  /**\n   * @internal\n   * Future: We could consider using a `Symbol.for(\"dataverse/PointerToPrismProvider\")` as a key here, similar to\n   * how {@link Iterable} works for `of`.\n   */\n  readonly $$isPointerToPrismProvider: true\n  /**\n   * Returns a prism of the value at the provided pointer.\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P>\n}\n\nexport function isPointerToPrismProvider(\n  val: unknown,\n): val is PointerToPrismProvider {\n  return (\n    typeof val === 'object' &&\n    val !== null &&\n    (val as $IntentionalAny)['$$isPointerToPrismProvider'] === true\n  )\n}\n\n/**\n * Returns a prism of the value at the provided pointer. Prisms are\n * cached per pointer.\n *\n * @param pointer - The pointer to return the prism at.\n */\n\nexport const pointerToPrism = <P extends PointerType<$IntentionalAny>>(\n  pointer: P,\n): Prism<P extends PointerType<infer T> ? T : void> => {\n  const meta = getPointerMeta(pointer)\n\n  let prismInstance = identifyPrismWeakMap.get(meta)\n  if (!prismInstance) {\n    const root = meta.root\n    if (!isPointerToPrismProvider(root)) {\n      throw new Error(\n        `Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider`,\n      )\n    }\n    prismInstance = root.pointerToPrism(pointer as $IntentionalAny)\n    identifyPrismWeakMap.set(meta, prismInstance)\n  }\n  return prismInstance as $IntentionalAny\n}\n", "import type {Prism} from './prism/Interface'\nimport {isPrism} from './prism/Interface'\nimport type {PointerType} from './pointer'\nimport {isPointer} from './pointer'\nimport type {$IntentionalAny} from './types'\nimport {pointerToPrism} from './pointerToPrism'\n\n/**\n * Convenience function that returns a plain value from its argument, whether it\n * is a pointer, a prism or a plain value itself.\n *\n * @remarks\n * For pointers, the value is returned by first creating a prism, so it is\n * reactive e.g. when used in a `prism`.\n *\n * @param input - The argument to return a value from.\n */\n\nexport const val = <\n  P extends\n    | PointerType<$IntentionalAny>\n    | Prism<$IntentionalAny>\n    | undefined\n    | null,\n>(\n  input: P,\n): P extends PointerType<infer T>\n  ? T\n  : P extends Prism<infer T>\n  ? T\n  : P extends undefined | null\n  ? P\n  : unknown => {\n  if (isPointer(input)) {\n    return pointerToPrism(input).getValue() as $IntentionalAny\n  } else if (isPrism(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n", "import {pointerToPrism} from '../pointerToPrism'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\n\nexport default function* iterateAndCountTicks<V>(\n  pointerOrPrism: Prism<V> | Pointer<V>,\n): Generator<{value: V; ticks: number}, void, void> {\n  let d\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism) as Prism<V>\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism\n  } else {\n    throw new Error(`Only pointers and prisms are supported`)\n  }\n\n  let ticksCountedSinceLastYield = 0\n  const untap = d.onStale(() => {\n    ticksCountedSinceLastYield++\n  })\n\n  try {\n    while (true) {\n      const ticks = ticksCountedSinceLastYield\n      ticksCountedSinceLastYield = 0\n      yield {value: d.getValue(), ticks}\n    }\n  } finally {\n    untap()\n  }\n}\n", "type ICallback = (t: number) => void\n\n/**\n * The number of ticks that can pass without any scheduled callbacks before the Ticker goes dormant. This is to prevent\n * the Ticker from staying active forever, even if there are no scheduled callbacks.\n *\n * Perhaps counting ticks vs. time is not the best way to do this. But it's a start.\n */\nexport const EMPTY_TICKS_BEFORE_GOING_DORMANT = 60 /*fps*/ * 3 /*seconds*/ // on a 60fps screen, 3 seconds should pass before the ticker goes dormant\n\n/**\n * The Ticker class helps schedule callbacks. Scheduled callbacks are executed per tick. Ticks can be triggered by an\n * external scheduling strategy, e.g. a raf.\n */\nexport default class Ticker {\n  private _scheduledForThisOrNextTick: Set<ICallback>\n  private _scheduledForNextTick: Set<ICallback>\n  private _timeAtCurrentTick: number\n  private _ticking: boolean = false\n\n  /**\n   * Whether the Ticker is dormant\n   */\n  private _dormant: boolean = true\n\n  private _numberOfDormantTicks = 0\n\n  /**\n   * Whether the Ticker is dormant\n   */\n  get dormant(): boolean {\n    return this._dormant\n  }\n  /**\n   * Counts up for every tick executed.\n   * Internally, this is used to measure ticks per second.\n   *\n   * This is \"public\" to TypeScript, because it's a tool for performance measurements.\n   * Consider this as experimental, and do not rely on it always being here in future releases.\n   */\n  public __ticks = 0\n\n  constructor(\n    private _conf?: {\n      /**\n       * This is called when the Ticker goes dormant.\n       */\n      onDormant?: () => void\n      /**\n       * This is called when the Ticker goes active.\n       */\n      onActive?: () => void\n    },\n  ) {\n    this._scheduledForThisOrNextTick = new Set()\n    this._scheduledForNextTick = new Set()\n    this._timeAtCurrentTick = 0\n  }\n\n  /**\n   * Registers for fn to be called either on this tick or the next tick.\n   *\n   * If `onThisOrNextTick()` is called while `Ticker.tick()` is running, the\n   * side effect _will_ be called within the running tick. If you don't want this\n   * behavior, you can use `onNextTick()`.\n   *\n   * Note that `fn` will be added to a `Set()`. Which means, if you call `onThisOrNextTick(fn)`\n   * with the same fn twice in a single tick, it'll only run once.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see offThisOrNextTick\n   */\n  onThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.add(fn)\n    if (this._dormant) {\n      this._goActive()\n    }\n  }\n\n  /**\n   * Registers a side effect to be called on the next tick.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see onThisOrNextTick\n   * @see offNextTick\n   */\n  onNextTick(fn: ICallback) {\n    this._scheduledForNextTick.add(fn)\n    if (this._dormant) {\n      this._goActive()\n    }\n  }\n\n  /**\n   * De-registers a fn to be called either on this tick or the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onThisOrNextTick\n   */\n  offThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.delete(fn)\n  }\n\n  /**\n   * De-registers a fn to be called on the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onNextTick\n   */\n  offNextTick(fn: ICallback) {\n    this._scheduledForNextTick.delete(fn)\n  }\n\n  /**\n   * The time at the start of the current tick if there is a tick in progress, otherwise defaults to\n   * `performance.now()`.\n   */\n  get time() {\n    if (this._ticking) {\n      return this._timeAtCurrentTick\n    } else return performance.now()\n  }\n\n  private _goActive() {\n    if (!this._dormant) return\n    this._dormant = false\n    this._conf?.onActive?.()\n  }\n\n  private _goDormant() {\n    if (this._dormant) return\n    this._dormant = true\n    this._numberOfDormantTicks = 0\n    this._conf?.onDormant?.()\n  }\n\n  /**\n   * Triggers a tick which starts executing the callbacks scheduled for this tick.\n   *\n   * @param t - The time at the tick.\n   *\n   * @see onThisOrNextTick\n   * @see onNextTick\n   */\n  tick(t: number = performance.now()) {\n    if (process.env.NODE_ENV === 'development') {\n      if (!(this instanceof Ticker)) {\n        throw new Error(\n          'ticker.tick must be called while bound to the ticker. As in, \"ticker.tick(time)\" or \"requestAnimationFrame((t) => ticker.tick(t))\" for performance.',\n        )\n      }\n    }\n\n    this.__ticks++\n\n    if (!this._dormant) {\n      if (\n        this._scheduledForNextTick.size === 0 &&\n        this._scheduledForThisOrNextTick.size === 0\n      ) {\n        this._numberOfDormantTicks++\n        if (this._numberOfDormantTicks >= EMPTY_TICKS_BEFORE_GOING_DORMANT) {\n          this._goDormant()\n          return\n        }\n      }\n    }\n\n    this._ticking = true\n    this._timeAtCurrentTick = t\n    for (const v of this._scheduledForNextTick) {\n      this._scheduledForThisOrNextTick.add(v)\n    }\n\n    this._scheduledForNextTick.clear()\n    this._tick(0)\n    this._ticking = false\n  }\n\n  private _tick(iterationNumber: number): void {\n    const time = this.time\n\n    if (iterationNumber > 10) {\n      console.warn('_tick() recursing for 10 times')\n    }\n\n    if (iterationNumber > 100) {\n      throw new Error(`Maximum recursion limit for _tick()`)\n    }\n\n    const oldSet = this._scheduledForThisOrNextTick\n    this._scheduledForThisOrNextTick = new Set()\n    for (const fn of oldSet) {\n      fn(time)\n    }\n\n    if (this._scheduledForThisOrNextTick.size > 0) {\n      return this._tick(iterationNumber + 1)\n    }\n  }\n}\n", "import {pointerToPrism} from '../pointerToPrism'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport Ticker from '../Ticker'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\n\nexport default function* iterateOver<V>(\n  pointerOrPrism: Prism<V> | Pointer<V>,\n): Generator<V, void, void> {\n  let d\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism) as Prism<V>\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism\n  } else {\n    throw new Error(`Only pointers and prisms are supported`)\n  }\n\n  const ticker = new Ticker()\n\n  const untap = d.onChange(ticker, (v) => {})\n\n  try {\n    while (true) {\n      ticker.tick()\n\n      yield d.getValue()\n    }\n  } finally {\n    untap()\n  }\n}\n", "import Atom from './Atom'\nimport {val} from './val'\nimport type {Pointer} from './pointer'\nimport {getPointerMeta} from './pointer'\nimport pointer from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport prism from './prism/prism'\nimport type {Prism} from './prism/Interface'\nimport type {PointerToPrismProvider} from './pointerToPrism'\n\n/**\n * Allows creating pointer-prisms where the pointer can be switched out.\n *\n * @remarks\n * This allows reacting not just to value changes at a certain pointer, but changes\n * to the proxied pointer too.\n */\nexport default class PointerProxy<O extends {}>\n  implements PointerToPrismProvider\n{\n  /**\n   * @internal\n   */\n  readonly $$isPointerToPrismProvider = true\n  private readonly _currentPointerBox: Atom<Pointer<O>>\n  /**\n   * Convenience pointer pointing to the root of this PointerProxy.\n   *\n   * @remarks\n   * Allows convenient use of {@link pointerToPrism} and {@link val}.\n   */\n  readonly pointer: Pointer<O>\n\n  constructor(currentPointer: Pointer<O>) {\n    this._currentPointerBox = new Atom(currentPointer)\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  /**\n   * Sets the underlying pointer.\n   * @param p - The pointer to be proxied.\n   */\n  setPointer(p: Pointer<O>) {\n    this._currentPointerBox.set(p)\n  }\n\n  /**\n   * Returns a prism of the value at the provided sub-path of the proxied pointer.\n   *\n   * @param path - The path to create the prism at.\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P> {\n    const {path} = getPointerMeta(pointer)\n    return prism(() => {\n      const currentPointer = this._currentPointerBox.prism.getValue()\n      const subPointer = path.reduce(\n        (pointerSoFar, pathItem) => (pointerSoFar as $IntentionalAny)[pathItem],\n        currentPointer,\n      )\n      return val(subPointer) as P\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
